diff --git a/drivers/tty/n_hdlc.c b/drivers/tty/n_hdlc.c
index eea7b6cb3..cb9662439 100644
--- a/drivers/tty/n_hdlc.c
+++ b/drivers/tty/n_hdlc.c
@@ -1,4 +1,3 @@
-// SPDX-License-Identifier: GPL-1.0+
 /* generic HDLC line discipline for Linux
  *
  * Written by Paul Fulghum paulkf@microgate.com
@@ -12,6 +11,8 @@
  *
  * Original release 01/11/99
  *
+ * This code is released under the GNU General Public License (GPL)
+ *
  * This module implements the tty line discipline N_HDLC for use with
  * tty device drivers that support bit-synchronous HDLC communications.
  *
@@ -113,7 +114,7 @@
 #define DEFAULT_TX_BUF_COUNT 3
 
 struct n_hdlc_buf {
-	struct list_head  list_item;
+	struct n_hdlc_buf *link;
 	int		  count;
 	char		  buf[1];
 };
@@ -121,7 +122,8 @@ struct n_hdlc_buf {
 #define	N_HDLC_BUF_SIZE	(sizeof(struct n_hdlc_buf) + maxframe)
 
 struct n_hdlc_buf_list {
-	struct list_head  list;
+	struct n_hdlc_buf *head;
+	struct n_hdlc_buf *tail;
 	int		  count;
 	spinlock_t	  spinlock;
 };
@@ -134,6 +136,7 @@ struct n_hdlc_buf_list {
  * @backup_tty - TTY to use if tty gets closed
  * @tbusy - reentrancy flag for tx wakeup code
  * @woke_up - FIXME: describe this field
+ * @tbuf - currently transmitting tx buffer
  * @tx_buf_list - list of pending transmit frame buffers
  * @rx_buf_list - list of received frame buffers
  * @tx_free_buf_list - list unused transmit frame buffers
@@ -146,6 +149,7 @@ struct n_hdlc {
 	struct tty_struct	*backup_tty;
 	int			tbusy;
 	int			woke_up;
+	struct n_hdlc_buf	*tbuf;
 	struct n_hdlc_buf_list	tx_buf_list;
 	struct n_hdlc_buf_list	rx_buf_list;
 	struct n_hdlc_buf_list	tx_free_buf_list;
@@ -155,8 +159,6 @@ struct n_hdlc {
 /*
  * HDLC buffer list manipulation functions
  */
-static void n_hdlc_buf_return(struct n_hdlc_buf_list *buf_list,
-						struct n_hdlc_buf *buf);
 static void n_hdlc_buf_put(struct n_hdlc_buf_list *list,
 			   struct n_hdlc_buf *buf);
 static struct n_hdlc_buf *n_hdlc_buf_get(struct n_hdlc_buf_list *list);
@@ -206,9 +208,17 @@ static void flush_tx_queue(struct tty_struct *tty)
 {
 	struct n_hdlc *n_hdlc = tty2n_hdlc(tty);
 	struct n_hdlc_buf *buf;
+	unsigned long flags;
 
-	while ((buf = n_hdlc_buf_get(&n_hdlc->tx_buf_list)))
+	while ((buf = n_hdlc_buf_get(&n_hdlc->tx_buf_list))) {
 		n_hdlc_buf_put(&n_hdlc->tx_free_buf_list, buf);
+	}
+	spin_lock_irqsave(&n_hdlc->tx_buf_list.spinlock, flags);
+	if (n_hdlc->tbuf) {
+		n_hdlc_buf_put(&n_hdlc->tx_free_buf_list, n_hdlc->tbuf);
+		n_hdlc->tbuf = NULL;
+	}
+	spin_unlock_irqrestore(&n_hdlc->tx_buf_list.spinlock, flags);
 }
 
 static struct tty_ldisc_ops n_hdlc_ldisc = {
@@ -234,7 +244,7 @@ static void n_hdlc_release(struct n_hdlc *n_hdlc)
 {
 	struct tty_struct *tty = n_hdlc2tty (n_hdlc);
 	struct n_hdlc_buf *buf;
-	
+
 	if (debuglevel >= DEBUG_LEVEL_INFO)	
 		printk("%s(%d)n_hdlc_release() called\n",__FILE__,__LINE__);
 		
@@ -256,6 +266,7 @@ static void n_hdlc_release(struct n_hdlc *n_hdlc)
 	for(;;) {
 		buf = n_hdlc_buf_get(&n_hdlc->tx_free_buf_list);
 		if (buf) {
+			//printk("ptr: %lx\n", (long)buf);
 			kfree(buf);
 		} else
 			break;
@@ -274,6 +285,7 @@ static void n_hdlc_release(struct n_hdlc *n_hdlc)
 		} else
 			break;
 	}
+	kfree(n_hdlc->tbuf);
 	kfree(n_hdlc);
 	
 }	/* end of n_hdlc_release() */
@@ -311,7 +323,7 @@ static void n_hdlc_tty_close(struct tty_struct *tty)
 			n_hdlc_release (n_hdlc);
 		}
 	}
-	
+
 	if (debuglevel >= DEBUG_LEVEL_INFO)	
 		printk("%s(%d)n_hdlc_tty_close() success\n",__FILE__,__LINE__);
 		
@@ -355,7 +367,7 @@ static int n_hdlc_tty_open (struct tty_struct *tty)
 	
 	/* flush receive data from driver */
 	tty_driver_flush_buffer(tty);
-		
+
 	if (debuglevel >= DEBUG_LEVEL_INFO)	
 		printk("%s(%d)n_hdlc_tty_open() success\n",__FILE__,__LINE__);
 		
@@ -392,7 +404,13 @@ static void n_hdlc_send_frames(struct n_hdlc *n_hdlc, struct tty_struct *tty)
 	n_hdlc->woke_up = 0;
 	spin_unlock_irqrestore(&n_hdlc->tx_buf_list.spinlock, flags);
 
-	tbuf = n_hdlc_buf_get(&n_hdlc->tx_buf_list);
+	/* get current transmit buffer or get new transmit */
+	/* buffer from list of pending transmit buffers */
+
+	tbuf = n_hdlc->tbuf;
+	if (!tbuf)
+		tbuf = n_hdlc_buf_get(&n_hdlc->tx_buf_list);
+
 	while (tbuf) {
 		if (debuglevel >= DEBUG_LEVEL_INFO)	
 			printk("%s(%d)sending frame %p, count=%d\n",
@@ -404,14 +422,14 @@ static void n_hdlc_send_frames(struct n_hdlc *n_hdlc, struct tty_struct *tty)
 
 		/* rollback was possible and has been done */
 		if (actual == -ERESTARTSYS) {
-			n_hdlc_buf_return(&n_hdlc->tx_buf_list, tbuf);
+			n_hdlc->tbuf = tbuf;
 			break;
 		}
 		/* if transmit error, throw frame away by */
 		/* pretending it was accepted by driver */
 		if (actual < 0)
 			actual = tbuf->count;
-		
+
 		if (actual == tbuf->count) {
 			if (debuglevel >= DEBUG_LEVEL_INFO)	
 				printk("%s(%d)frame %p completed\n",
@@ -420,6 +438,9 @@ static void n_hdlc_send_frames(struct n_hdlc *n_hdlc, struct tty_struct *tty)
 			/* free current transmit buffer */
 			n_hdlc_buf_put(&n_hdlc->tx_free_buf_list, tbuf);
 
+			/* this tx buffer is done */
+			n_hdlc->tbuf = NULL;
+
 			/* wait up sleeping writers */
 			wake_up_interruptible(&tty->write_wait);
 	
@@ -430,11 +451,9 @@ static void n_hdlc_send_frames(struct n_hdlc *n_hdlc, struct tty_struct *tty)
 				printk("%s(%d)frame %p pending\n",
 					__FILE__,__LINE__,tbuf);
 
-			/*
-			 * the buffer was not accepted by driver,
-			 * return it back into tx queue
-			 */
-			n_hdlc_buf_return(&n_hdlc->tx_buf_list, tbuf);
+			/* buffer not accepted by driver */
+			/* set this buffer as pending buffer */
+			n_hdlc->tbuf = tbuf;
 			break;
 		}
 	}
@@ -446,13 +465,13 @@ static void n_hdlc_send_frames(struct n_hdlc *n_hdlc, struct tty_struct *tty)
 	spin_lock_irqsave(&n_hdlc->tx_buf_list.spinlock, flags);
 	n_hdlc->tbusy = 0;
 	spin_unlock_irqrestore(&n_hdlc->tx_buf_list.spinlock, flags); 
-	
-        if (n_hdlc->woke_up)
+
+	if (n_hdlc->woke_up)
 	  goto check_again;
 
 	if (debuglevel >= DEBUG_LEVEL_INFO)	
 		printk("%s(%d)n_hdlc_send_frames() exit\n",__FILE__,__LINE__);
-		
+
 }	/* end of n_hdlc_send_frames() */
 
 /**
@@ -477,7 +496,7 @@ static void n_hdlc_tty_wakeup(struct tty_struct *tty)
 	}
 
 	n_hdlc_send_frames (n_hdlc, tty);
-		
+
 }	/* end of n_hdlc_tty_wakeup() */
 
 /**
@@ -510,7 +529,7 @@ static void n_hdlc_tty_receive(struct tty_struct *tty, const __u8 *data,
 			__FILE__,__LINE__);
 		return;
 	}
-	
+
 	if ( count>maxframe ) {
 		if (debuglevel >= DEBUG_LEVEL_INFO)	
 			printk("%s(%d) rx count>maxframesize, data discarded\n",
@@ -629,7 +648,7 @@ static ssize_t n_hdlc_tty_read(struct tty_struct *tty, struct file *file,
 	__set_current_state(TASK_RUNNING);
 
 	return ret;
-	
+
 }	/* end of n_hdlc_tty_read() */
 
 /**
@@ -732,7 +751,6 @@ static int n_hdlc_tty_ioctl(struct tty_struct *tty, struct file *file,
 	int error = 0;
 	int count;
 	unsigned long flags;
-	struct n_hdlc_buf *buf = NULL;
 
 	if (debuglevel >= DEBUG_LEVEL_INFO)	
 		printk("%s(%d)n_hdlc_tty_ioctl() called %d\n",
@@ -747,10 +765,8 @@ static int n_hdlc_tty_ioctl(struct tty_struct *tty, struct file *file,
 		/* report count of read data available */
 		/* in next available frame (if any) */
 		spin_lock_irqsave(&n_hdlc->rx_buf_list.spinlock,flags);
-		buf = list_first_entry_or_null(&n_hdlc->rx_buf_list.list,
-						struct n_hdlc_buf, list_item);
-		if (buf)
-			count = buf->count;
+		if (n_hdlc->rx_buf_list.head)
+			count = n_hdlc->rx_buf_list.head->count;
 		else
 			count = 0;
 		spin_unlock_irqrestore(&n_hdlc->rx_buf_list.spinlock,flags);
@@ -762,10 +778,8 @@ static int n_hdlc_tty_ioctl(struct tty_struct *tty, struct file *file,
 		count = tty_chars_in_buffer(tty);
 		/* add size of next output frame in queue */
 		spin_lock_irqsave(&n_hdlc->tx_buf_list.spinlock,flags);
-		buf = list_first_entry_or_null(&n_hdlc->tx_buf_list.list,
-						struct n_hdlc_buf, list_item);
-		if (buf)
-			count += buf->count;
+		if (n_hdlc->tx_buf_list.head)
+			count += n_hdlc->tx_buf_list.head->count;
 		spin_unlock_irqrestore(&n_hdlc->tx_buf_list.spinlock,flags);
 		error = put_user(count, (int __user *)arg);
 		break;
@@ -813,14 +827,14 @@ static unsigned int n_hdlc_tty_poll(struct tty_struct *tty, struct file *filp,
 		poll_wait(filp, &tty->write_wait, wait);
 
 		/* set bits for operations that won't block */
-		if (!list_empty(&n_hdlc->rx_buf_list.list))
+		if (n_hdlc->rx_buf_list.head)
 			mask |= POLLIN | POLLRDNORM;	/* readable */
 		if (test_bit(TTY_OTHER_CLOSED, &tty->flags))
 			mask |= POLLHUP;
 		if (tty_hung_up_p(filp))
 			mask |= POLLHUP;
 		if (!tty_is_writelocked(tty) &&
-				!list_empty(&n_hdlc->tx_free_buf_list.list))
+				n_hdlc->tx_free_buf_list.head)
 			mask |= POLLOUT | POLLWRNORM;	/* writable */
 	}
 	return mask;
@@ -845,11 +859,6 @@ static struct n_hdlc *n_hdlc_alloc(void)
 	spin_lock_init(&n_hdlc->rx_buf_list.spinlock);
 	spin_lock_init(&n_hdlc->tx_buf_list.spinlock);
 
-	INIT_LIST_HEAD(&n_hdlc->rx_free_buf_list.list);
-	INIT_LIST_HEAD(&n_hdlc->tx_free_buf_list.list);
-	INIT_LIST_HEAD(&n_hdlc->rx_buf_list.list);
-	INIT_LIST_HEAD(&n_hdlc->tx_buf_list.list);
-
 	/* allocate free rx buffer list */
 	for(i=0;i<DEFAULT_RX_BUF_COUNT;i++) {
 		buf = kmalloc(N_HDLC_BUF_SIZE, GFP_KERNEL);
@@ -876,73 +885,61 @@ static struct n_hdlc *n_hdlc_alloc(void)
 	
 }	/* end of n_hdlc_alloc() */
 
-/**
- * n_hdlc_buf_return - put the HDLC buffer after the head of the specified list
- * @buf_list - pointer to the buffer list
- * @buf - pointer to the buffer
- */
-static void n_hdlc_buf_return(struct n_hdlc_buf_list *buf_list,
-						struct n_hdlc_buf *buf)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&buf_list->spinlock, flags);
-
-	list_add(&buf->list_item, &buf_list->list);
-	buf_list->count++;
-
-	spin_unlock_irqrestore(&buf_list->spinlock, flags);
-}
-
 /**
  * n_hdlc_buf_put - add specified HDLC buffer to tail of specified list
- * @buf_list - pointer to buffer list
+ * @list - pointer to buffer list
  * @buf	- pointer to buffer
  */
-static void n_hdlc_buf_put(struct n_hdlc_buf_list *buf_list,
+static void n_hdlc_buf_put(struct n_hdlc_buf_list *list,
 			   struct n_hdlc_buf *buf)
 {
 	unsigned long flags;
+	spin_lock_irqsave(&list->spinlock,flags);
 
-	spin_lock_irqsave(&buf_list->spinlock, flags);
+	buf->link=NULL;
+	if (list->tail)
+		list->tail->link = buf;
+	else
+		list->head = buf;
+	list->tail = buf;
+	(list->count)++;
 
-	list_add_tail(&buf->list_item, &buf_list->list);
-	buf_list->count++;
+	spin_unlock_irqrestore(&list->spinlock,flags);
 
-	spin_unlock_irqrestore(&buf_list->spinlock, flags);
 }	/* end of n_hdlc_buf_put() */
 
 /**
  * n_hdlc_buf_get - remove and return an HDLC buffer from list
- * @buf_list - pointer to HDLC buffer list
+ * @list - pointer to HDLC buffer list
  * 
  * Remove and return an HDLC buffer from the head of the specified HDLC buffer
  * list.
  * Returns a pointer to HDLC buffer if available, otherwise %NULL.
  */
-static struct n_hdlc_buf *n_hdlc_buf_get(struct n_hdlc_buf_list *buf_list)
+static struct n_hdlc_buf* n_hdlc_buf_get(struct n_hdlc_buf_list *list)
 {
 	unsigned long flags;
 	struct n_hdlc_buf *buf;
+	spin_lock_irqsave(&list->spinlock,flags);
 
-	spin_lock_irqsave(&buf_list->spinlock, flags);
-
-	buf = list_first_entry_or_null(&buf_list->list,
-						struct n_hdlc_buf, list_item);
+	buf = list->head;
 	if (buf) {
-		list_del(&buf->list_item);
-		buf_list->count--;
+		list->head = buf->link;
+		(list->count)--;
 	}
+	if (!list->head)
+		list->tail = NULL;
 
-	spin_unlock_irqrestore(&buf_list->spinlock, flags);
+	spin_unlock_irqrestore(&list->spinlock,flags);
 	return buf;
+
 }	/* end of n_hdlc_buf_get() */
 
-static const char hdlc_banner[] __initconst =
+static char hdlc_banner[] __initdata =
 	KERN_INFO "HDLC line discipline maxframe=%u\n";
-static const char hdlc_register_ok[] __initconst =
+static char hdlc_register_ok[] __initdata =
 	KERN_INFO "N_HDLC line discipline registered.\n";
-static const char hdlc_register_fail[] __initconst =
+static char hdlc_register_fail[] __initdata =
 	KERN_ERR "error registering line discipline: %d\n";
 
 static int __init n_hdlc_init(void)
@@ -967,9 +964,9 @@ static int __init n_hdlc_init(void)
 	
 }	/* end of init_module() */
 
-static const char hdlc_unregister_ok[] __exitdata =
+static char hdlc_unregister_ok[] __exitdata =
 	KERN_INFO "N_HDLC: line discipline unregistered\n";
-static const char hdlc_unregister_fail[] __exitdata =
+static char hdlc_unregister_fail[] __exitdata =
 	KERN_ERR "N_HDLC: can't unregister line discipline (err = %d)\n";
 
 static void __exit n_hdlc_exit(void)
diff --git a/security/keys/keyctl.c b/security/keys/keyctl.c
index 1ffe60bb2..2e5b1f00f 100644
--- a/security/keys/keyctl.c
+++ b/security/keys/keyctl.c
@@ -133,7 +133,7 @@ SYSCALL_DEFINE5(add_key, const char __user *, _type,
 	key_ref_put(keyring_ref);
  error3:
 	if (payload) {
-		memzero_explicit(payload, plen);
+		//memzero_explicit(payload, plen);
 		kvfree(payload);
 	}
  error2:
